# Задача 18: Требуется найти в массиве A[1..N] самый близкий по величине элемент к заданному числу X. 
# Пользователь в первой строке вводит натуральное число N – количество элементов в массиве. 
# В последующих  строках записаны N целых чисел Ai. Последняя строка содержит число X
# *Пример:*
# 5
#     1 2 3 4 5
#     6
#     -> 5

# from random import randint
# mas = [randint(1, 100) for _ in range(int(input('Введите число цифр массива: ')))]
# print(mas)
# n = int(input('Введите искомое число в диапзоне от 1 до 100: '))
# diff = 0
# min_diff = 100
# maxApprNum = 0
# for i in mas:
#     if i == n:
#         print(f'Заданное Вами число {n} есть в массиве.')
#     elif i > n:
#         diff = i - n
#         if diff < min_diff:
#             min_diff = diff
#             maxApprNum = i
#     elif i < n:
#         diff = (i - n) * -1
#         if diff < min_diff:
#             min_diff = diff
#             maxApprNum = i
# print(f'Максимально близкое к заданному числу {n}, соответствует число {maxApprNum}.')

# вроде и решил, но результат не нравится, если заданное число есть в массиве, 
# помимо сообющения о том, что искомое число есть в массиве, он все равно дополнительно выдает сообщение
# ближайшее число


# --------------------------------------------------------------------------------------------------------
# решение с семинара через создание второго массива

# from random import randint

# N = int(input('Введите количество элементов массива: '))
# lst = [randint(1, 100) for _ in range(N)]
# print(lst)

# x = int(input('Введите число "Х": '))
# lst_2 = []

# for i in lst: 
#     j = abs(i - x)  # функция "abs()" выдвет абсолютное хначение, т.е. положительное
#     lst_2.append(j)

# print(f'Ближайшее по величине значение к числу {x} = {lst[lst_2.index(min(lst_2))]}.') 
# # {lst[lst_2.index(min(lst_2))]} - расшивровать это можно так, находим минимальное значение массива "lst_2", 
# # далее находим индекс эго значения, потом берем этот же индекс и возвращаем число находящееся под этим же инжексом в массиве "lst"



# --------------------------------------------------------------------------------------------------------
# решение с семинара без создания дополнительных массива

# from random import randint

# lst = [randint(-10, 10) for _ in range(int(input('Задайте количство элементов массива: ')))]
# print(f'Массив: {lst}')

# k = int(input('Введите число: '))
# difference = abs(lst[0] - k) # создаем переменную в которую будем записывать разницу между элементом индекса и искомым числом, 
# # с исходным значением равным разнице между числом на нулевом индексе и искомым числом
# target = lst[0] # для максимально приближенного значения к искомому числу принимает значение элемента с нудевым индексом нашего массива

# for i in lst:
#     diff = abs(i - k)
#     if diff < difference:
#         difference = diff
#         target = i

# print(f'Самый близкий элемент массива к числу {k} -> {target}.')



# --------------------------------------------------------------------------------------------------------
# решение с семинара с созданием словарей (какое то лютое решение)

# from random import randint
# n = int(input('Введите количество элементов: '))
# x = int(input('Введите число: '))
# lst = [randint(1, n) for i in range(n)]
# nearest = min(lst, key=lambda i:abs(i-x))
# # создаем словарь под каждым ключем которого будет записан элемент нашего списка
# print(lst)
# print(f'{nearest} ближайшее число к {x}')


# --------------------------------------------------------------------------------------------------------
# решение от препода (тоже крутое, но более понятное)

from random import randint

n = int(input('Введите количество элементов: '))
lst = [randint(1, n) for _ in range(n)]
print(lst)
x = int(input('Введите число: '))
# далее используем генератор словарей, мы будем создавать ключ, который будет из себя представлять разницу между "х" и 
# конкретным элементом нашего списка, а значением для ключа будет служить значение данного элемента списка

dct = {abs(x - item): item for item in lst} # item - переменная, текущий элемент списка
# abs(x - item): item  - до двоеточия ключ, после значение

print(dct)      # печатаем получившийся словарь
print(dct[min(dct)])  # находим самый минимальный ключ и выводим значение этого ключа